import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// keywords
terminal DEF, PROC, CALL, LET, IF, THEN, ELSE, CASE;

// standard I/O
terminal PRINT, PRINTLN, READ, READINT;

// special symbols
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQPAREN, RSQPAREN, VECT_OPEN, VECT_CLOSE;
terminal ASSIGN, EQUAL, COMMA, DOT, COLON, SEMI;

// compound data operators
terminal LSTCONCAT;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, EXP;

// bit-wise operators
terminal BIT_AND, BIT_OR, BIT_NOT;

// comparators
terminal LESS, LESSEQ, GREATEREQ, GREATER, NEQUAL;

// boolean operators
terminal AND, OR, NOT;

// terminals with values
terminal String VAR;
terminal Double INT, DOUBLE;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String STRING;
terminal NIL;

/* Non terminals */
non terminal ArithProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;

non terminal Statement print;

non terminal StmtDefinition definition;
non terminal Statement assignment;

non terminal Exp compoundExpr;
non terminal Exp expression;
non terminal Exp and;
non terminal Exp not;
non terminal Exp comparator;
non terminal Exp bitwiseBinOp;
non terminal Exp arithExp;
non terminal Exp term;
non terminal Exp power;
non terminal Exp bitwiseNot;
non terminal Exp lit;
non terminal Exp complexLit;

non terminal ExpLet let;
non terminal ArrayList<ExpBind> bindList;
non terminal ExpBind binding;

non terminal StmtFunDefn funDefn;
non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;

non terminal ExpCase case;
non terminal ArrayList<Exp> clauseLst;
non terminal ExpClause clause;

non terminal ExpIf ifStmt;
non terminal Exp else;

non terminal Exp funCall;
non terminal ArrayList<Exp> argList;
non terminal ArrayList<Exp> argListE;

non terminal Exp read;

non terminal ExpList list;
non terminal ArrayList<Exp> pairElementLst;

non terminal ExpVector vector;
non terminal ArrayList<Exp> vectorElementLst;
non terminal Exp vectEl;
non terminal ExpGetVectEl vectorAccess;

non terminal empty;

/* Grammar rules */

program ::= stmtList:s {: RESULT = new ArithProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
				lst.add(s);
				RESULT = lst;
				:} |
	    stmt:s {: RESULT = new StmtSequence(s); :};

stmt ::= print:p {: RESULT = p; :} |
		definition:d {:RESULT = d; :} |
		assignment:a {:RESULT = a; :} |
		expression:e SEMI {:RESULT = new Statement(e); :};


print ::= PRINT LPAREN expression:e RPAREN SEMI {: RESULT = new StmtPrint(e); :} |
		PRINTLN LPAREN expression:e RPAREN SEMI{: RESULT = new StmtPrintln(e); :};


definition ::= DEF VAR:v expression:e SEMI {: 
					RESULT = new StmtDefinition(v, e); :};

assignment ::= VAR:v ASSIGN  expression:e SEMI {:
					RESULT = new StmtAssignment(v, e); :} |
				complexLit:l LSQPAREN expression:i RSQPAREN ASSIGN expression:e SEMI {:
					RESULT = new StmtSetVectEl(l, i, e); :};


compoundExpr ::= LBRACE stmtList:sList RBRACE {: RESULT = sList; :};/* |
				expression:e RBRACE {: RESULT = e; :}; */


//expression ::= expression:e LSTCONCAT and:a {: RESULT = new ExpLstConcat(e, a); :} |
expression ::= expression:e OR and:a {: RESULT = new ExpOr(e, a); :} |
				and:a {: RESULT = a; :};

and ::= and:a AND not:n {: RESULT = new ExpAnd(a, n); :} |
		not:n {: RESULT = n; :};

not ::= NOT comparator:c {: RESULT = new ExpNot(c); :} |
		comparator:c {: RESULT = c; :};

comparator ::= comparator:c LESS bitwiseBinOp:b {:
					RESULT = new ExpLess(c, b); :} |
				comparator:c LESSEQ bitwiseBinOp:b {:
					RESULT = new ExpLessEq(c, b); :} |
				comparator:c EQUAL bitwiseBinOp:b {:
					RESULT = new ExpEqual(c, b); :} |
				comparator:c GREATEREQ bitwiseBinOp:b {:
					RESULT = new ExpGreaterEq(c, b); :} |
				comparator:c GREATER bitwiseBinOp:b {:
					RESULT = new ExpGreater(c, b); :} |
				comparator:c NEQUAL bitwiseBinOp:b {:
					RESULT = new ExpNotEqual(c, b); :} |
				bitwiseBinOp:b {: RESULT = b; :};

bitwiseBinOp ::= bitwiseBinOp:b BIT_AND arithExp:a {:
					RESULT = new ExpBitwiseAnd(b, a); :} |
				bitwiseBinOp:b BIT_OR arithExp:a {:
					RESULT = new ExpBitwiseOr(b, a); :} |
				arithExp:a {: RESULT = a; :};

arithExp ::= arithExp:a PLUS term:t {:
				RESULT = new ExpAdd(a, t); :} |
			arithExp:a MINUS term:t {:
				RESULT = new ExpSub(a, t); :} |
			term:t {:
				RESULT = t; :};

term ::= term:t MUL power:p {:
			RESULT = new ExpMul(t, p); :} |
		term:t DIV power:p {:
			RESULT = new ExpDiv(t, p); :} |
		term:t MOD power:p {:
			RESULT = new ExpMod(t, p); :} |
		power:p {:
			RESULT = p; :};

power ::= bitwiseNot:b EXP power:p {: RESULT = new ExpPow(b, p); :} |
			bitwiseNot:b {: RESULT = b; :};

bitwiseNot ::= BIT_NOT lit:l {: RESULT = new ExpBitwiseNot(l); :} |
				lit:l {: RESULT = l; :};

lit ::= complexLit:l {: RESULT = l; :} |
		read:r {: RESULT = r; :} |
		NIL {: RESULT = new ExpLit("nil"); :} |
		INT:ilit {: RESULT = new ExpLit("number", ilit); :} |
		DOUBLE:dlit {: RESULT = new ExpLit("number", dlit); :} |
		BOOL:blit {: RESULT = new ExpLit("boolean", blit); :} |
		CHAR:charLit {: RESULT = new ExpLit("character", charLit); :} |
		STRING:strLit {: RESULT = new ExpLit("string", strLit); :};

complexLit ::= let:l {: RESULT = l; :} |
		funDefn:f {: RESULT = f; :} |
		case:c {: RESULT = c; :} |
		ifStmt:i {: RESULT = i; :} |
		funCall:fCall {: RESULT = fCall; :} |
		LPAREN compoundExpr:e RPAREN {: RESULT = e; :} |
		vectorAccess:vectGet {: RESULT = vectGet; :} |
		VAR:var {: RESULT = new ExpVar(var); :} |
		vector:vect {: RESULT = vect; :} |
		list:lst {: RESULT = lst; :};


let ::= LET LPAREN bindList:bindLst RPAREN compoundExpr:b {:
	 		RESULT = new ExpLet(bindLst, b); :};

bindList ::= bindList:bindLst COMMA binding:b {:
                bindLst.add(b);
                RESULT = bindLst; :} |
            binding:b {:
                ArrayList<ExpBind> result = new ArrayList<ExpBind>();
                result.add(b);
                RESULT = result; :};

binding ::= VAR:v EQUAL expression:e {: RESULT = new ExpBind(v, e); :};


funDefn ::= PROC LPAREN paramListE:pListE RPAREN compoundExpr:b {:
				RESULT = new StmtFunDefn(pListE, b); :} |
			PROC LPAREN paramList:pList DOT VAR:paramOvf RPAREN compoundExpr:b {:
				RESULT = new StmtFunDefn(pList, paramOvf, b); :} |
			PROC VAR:v compoundExpr:b {:
				RESULT = new StmtFunDefn(v, b); :};

paramList ::=  paramList:pList COMMA VAR:v {:
					pList.add(v);
					RESULT = pList; :} |
				VAR:v {:
					ArrayList<String> pList = new ArrayList<String>();
					pList.add(v);
					RESULT = pList; :};

paramListE ::= paramList:pList {: RESULT = pList; :} |
				empty {: RESULT = new ArrayList<String>(); :};


case ::= CASE LBRACE clauseLst:cList RBRACE {: RESULT = new ExpCase(cList); :};

clauseLst ::= clauseLst:cList COMMA clause:c {:
				cList.add(c);
				RESULT = cList; :} |
			clause:c {:
				ArrayList<Exp> cList = new ArrayList<Exp>();
				cList.add(c);
				RESULT = cList; :};

clause ::= expression:pred COLON compoundExpr:conseq {: RESULT = new ExpClause(pred, conseq); :};


ifStmt ::= IF expression:e THEN compoundExpr:conseq else:alt {:
				RESULT = new ExpIf(e, conseq, alt); :};

else  ::= ELSE compoundExpr:alt {: RESULT = alt; :} |
			empty {: RESULT = new ExpLit("none"); :};


funCall ::= CALL LPAREN expression:f COMMA expression:lst RPAREN {:
				RESULT = new ExpCall(f, lst); :} |
			complexLit:l LPAREN argListE:aListE RPAREN {:
				RESULT = new ExpFunCall(l, aListE); :};

argList ::= argList:aList COMMA expression:e {:
				aList.add(e);
				RESULT = aList; :} |
			expression:e {: ArrayList<Exp> aList = new ArrayList<Exp>();
					aList.add(e);
					RESULT = aList;
			:};

argListE ::= argList:aList {: RESULT = aList; :} |
			empty {: RESULT = new ArrayList<Exp>(); :};


read ::= READ LPAREN RPAREN {: RESULT = new ExpRead(); :} |
		READINT LPAREN RPAREN {: RESULT = new ExpReadInt(); :};


list ::= LSQPAREN pairElementLst:lst RSQPAREN {:
			RESULT = new ExpList(lst); :};

pairElementLst ::= pairElementLst:lst COMMA expression:e {:
			lst.add(e);
			RESULT = lst; :} |
		expression:e {:
			ArrayList<Exp> lst = new ArrayList<Exp>();
			lst.add(e);
			RESULT = lst; :};


vector ::= VECT_OPEN vectorElementLst:lst VECT_CLOSE {:
			RESULT = new ExpVector(lst); :};

vectorElementLst ::= vectorElementLst:lst COMMA vectEl:e {:
			lst.add(e);
			RESULT = lst; :} |
		vectEl:e {:
			ArrayList<Exp> lst = new ArrayList<Exp>();
			lst.add(e);
			RESULT = lst; :};

vectEl ::= expression:e {: RESULT = e; :};/* |
			expression:e COLON funDefn:f {: RESULT = new ExpSubVect(e, f) :};
*/
vectorAccess ::= complexLit:l LSQPAREN expression:i RSQPAREN {:
				RESULT = new ExpGetVectEl(l, i); :};


empty ::= ;
