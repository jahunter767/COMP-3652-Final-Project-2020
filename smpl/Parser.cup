import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// keywords
terminal DEF, PROC, CALL, LET, IF, THEN, ELSE, CASE;

// standard I/O
terminal PRINT, PRINTLN, READ, READINT;

// special symbols
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQPAREN, RSQPAREN, VECT_OPEN, VECT_CLOSE;
terminal ASSIGN, BIND, COMMA, DOT, COLON, SEMI,POP;

// compound data operators
terminal LSTCONCAT;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, EXP, INTDIV;

// bit-wise operators
terminal BIT_AND, BIT_OR, BIT_NOT;

// comparators
terminal LESS, LESSEQ, EQUAL, GREATEREQ, GREATER, NEQUAL;

// boolean operators
terminal AND, OR, NOT;

// terminals with values
terminal String VAR;
terminal Integer INT;
terminal Double DOUBLE;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String STRING;
terminal NIL;


//other terminals
terminal LIST,FUN,SIZE,TRUE,FALSE;

/* Non terminals */
non terminal ArithProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;

non terminal Statement print;
non terminal Exp read;

non terminal StmtDefinition definition;
non terminal StmtAssignment assignment;

non terminal Exp proc;
non terminal Exp body;
non terminal StmtSequence compoundExpr;

non terminal ExpLet let;
non terminal ArrayList<ExpBind> bindList;
non terminal ExpBind binding;




/*
non terminal StmtDefinition ifdefn;
*/

/* ** Fix these declarations ** */

non terminal StmtFunDefn funDefn;
non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;

non terminal ArrayList<Exp> args;
non terminal ArrayList<Exp> argsE;
non terminal ExpFunCall funcall;


/* **** */


/*
non terminal ArrayList<Exp> comparatorList;
non terminal StmtConditionalStmt conditionalIf;
non terminal StmtConditionalElseStmt conditionalIfElse;
*/

/*
non terminal Statement ifstmt;
non terminal Statement else;
non terminal Statement emptyElse;
*/

non terminal ExpCase case;
non terminal ArrayList<Exp> clauseLst;
non terminal ExpClause clause;

non terminal ExpIf ifStmt;
non terminal Exp else;

non terminal Exp Not;
non terminal Exp And;
non terminal Exp expression;



non terminal Exp arithExp;
non terminal Exp bitwiseBinOp;
non terminal Exp bitwiseNot;

non terminal Exp comparisonExpression;

/*
non terminal Exp conditionalExpression;
*/

non terminal Exp term;
non terminal Exp factor;
non terminal Exp atom;

non terminal Exp expr; // for all expressions
non terminal Exp Defnexpr; // for all definition expressions 
non terminal Exp str; // for strings
non terminal Exp concat; // for strings concat
non terminal Substr Substr; // for substrings

non terminal Eqv Eqv; // for eqv
non terminal Equal Equal; // for equals

non terminal Exp Pair;// for pairs
non terminal Exp List;// for list
non terminal Exp Listconcat;// for list concat

non terminal Car Car; // for car
non terminal Cdr Cdr; // for cdr


non terminal Exp vector;// for vector
non terminal ArrayList<Exp> vectorElementLst;
non terminal Exp vectorOps;


non terminal Exp empty;
non terminal ArrayList<Exp> emptyA;
non terminal ArrayList<String> emptyS;

/* Grammar rules */

program ::= stmtList:s {: RESULT = new ArithProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new StmtSequence(s);
		:};

stmt ::= Listconcat:lst {:RESULT = new Statement(lst); :} |vectorOps:v {: RESULT = new Statement(v); :}   | assignment:a {:RESULT = a; :}|let:l {: RESULT = new Statement(l); :} | case:c {: RESULT = new Statement(c); :} |ifStmt:i {: RESULT = new Statement(i); :}| read:r SEMI {: RESULT = new Statement(r); :} | print:p SEMI {: RESULT = p; :} | funDefn:func {: RESULT = func; :} | definition:d {: RESULT = d; :} | expression:a {: RESULT = new Statement(a); :} SEMI; // |conditionalExpression:conditional {: RESULT = new Statement(conditional); :}; // 



print ::= PRINT LPAREN expression:e RPAREN {: RESULT = new StmtPrint(e); :} |
		PRINTLN LPAREN expression:e RPAREN {: RESULT = new StmtPrintln(e); :};

read ::= READ LPAREN RPAREN {: RESULT = new ExpRead(); :} |
		READINT LPAREN RPAREN {: RESULT = new ExpReadInt(); :};


body ::= compoundExpr:sList {: RESULT = sList; :} |
		expression:e SEMI {: RESULT = e; :};

compoundExpr ::= LBRACE stmtList:sList RBRACE {: RESULT = sList; :} | expression:e{: RESULT = new StmtSequence(new Statement(e)); :};





//Car:car {:RESULT = new Statement(car); :} | Cdr:cdr {:RESULT = new Statement(cdr); :} |Pair:pair {:RESULT = new Statement(pair);:} | List:lst {:RESULT = new Statement(lst); :} | Eqv:eqv {:RESULT = new Statement(eqv); :} |Equal:equal {:RESULT = new Statement(equal); :} |Substr:subs {:RESULT = new Statement(subs); :} |

//str ::= STRING:s {: RESULT = new ExpLit<String>(s); :};
//lstconcat ::= expr:exp1 LSTCONCAT expr:exp2 {: RESULT = new Lstconcat(exp1,exp2); :};

// builtin functions - These are temp.. eventually will be removed

//Substr::= SUBSTR LPAREN expr:e COMMA arithExp:start COMMA arithExp:end RPAREN {: RESULT = new Substr(e,start,end); :};
//Eqv::= EQUIV_PRED LPAREN expr:exp1 COMMA expr:exp2  RPAREN {: RESULT = new Eqv(exp1,exp2); :};
//Equal ::= EQUAL_PRED LPAREN expr:exp1 COMMA expr:exp2  RPAREN {: RESULT = new Equal(exp1,exp2); :};

//Car::= CAR LPAREN expr:exp1 RPAREN {: RESULT = new Car(exp1); :};
//Cdr::= CDR LPAREN expr:exp1  RPAREN {: RESULT = new Cdr(exp1); :};

//Pair::= PAIR LPAREN expr:obj1 COMMA expr:obj2 RPAREN {: RESULT = new ExpPair(obj1,obj2);:};

List::= LIST LPAREN argsE:arguments RPAREN {:RESULT = new ExpList(arguments); :} | LSQPAREN argsE:arguments RSQPAREN {:RESULT = new ExpList(arguments); :};

Listconcat::= expression: exp1 LSTCONCAT expression: exp2 SEMI{: RESULT = new ExpListConcat(exp1, exp2); :};



vector ::= VECT_OPEN vectorElementLst:lst VECT_CLOSE {:
			RESULT = new ExpVector(lst); :};

vectorElementLst ::= vectorElementLst:lst COMMA expression:e {:
			lst.add(e);
			RESULT = lst; :} |
		expression:e {:
			ArrayList<Exp> lst = new ArrayList<Exp>();
			lst.add(e);
			RESULT = lst; :};

vectorOps ::= VAR:v LSQPAREN expression:i RSQPAREN SEMI {:
				RESULT = new ExpGetVectEl(v, i); :} |
			VAR:v LSQPAREN expression:i RSQPAREN ASSIGN expression:e SEMI {:
				RESULT = new ExpSetVectEl(v, i, e); :} |
			VAR:v DOT POP LPAREN expression:i RPAREN{:
				RESULT = new ExpPopVectEl(v, i); :};





funDefn ::= /*proc:p  {: RESULT = p; :}; // | */ PROC LPAREN paramListE:parameters RPAREN LBRACE stmtList:statements RBRACE {: RESULT = new StmtFunDefn(parameters, statements); :} ; // PROC LPAREN paramListE:p RPAREN DEFINE expression:a SEMI {: RESULT = new StmtFunDefn(v,p,new StmtSequence(new Statement(a))); :} |  


proc ::= PROC LPAREN paramListE:parameters RPAREN stmt:s {:RESULT = new StmtFunDefn(parameters,new StmtSequence(s)); :};

paramList ::= paramList:pList COMMA VAR:var {: 
	pList.add(var);
	RESULT = pList; :} |
	VAR:var {:
	ArrayList<String> result = new ArrayList<String>();
	result.add(var);
	RESULT = result;
	:}; 


paramListE ::= paramList:paramList {: RESULT = paramList; :} | emptyS:e {: RESULT = e; :};




definition ::= DEF VAR:v Defnexpr:exp {: RESULT = new StmtDefinition(v,exp); :};

assignment ::= VAR:v ASSIGN expression:e SEMI {: RESULT = new StmtAssignment(v, e); :};


Defnexpr ::= Listconcat:lst {:RESULT = new Statement(lst); :}  |vectorOps:v {: RESULT = new Statement(v); :} | case:c {: RESULT = new Statement(c); :} |ifStmt:i {: RESULT = new Statement(i); :} | expression:a SEMI {: RESULT = new Statement(a); :} | funDefn:func {: RESULT = func; :};

//Car:car {:RESULT = new Statement(car); :} | Cdr:cdr {:RESULT = new Statement(cdr); :} | Pair:pair {:RESULT = new Statement(pair);:} | List:lst {:RESULT = new Statement(lst); :} | str:s {: RESULT = new Statement(s); :} | Substr:str {: RESULT = new Statement(str); :} |

expr ::=  Listconcat:lst {:RESULT = new Statement(lst); :} | vectorOps:v {: RESULT = new Statement(v); :}  | case:c {: RESULT = new Statement(c); :} |ifStmt:i {: RESULT = new Statement(i); :} | expression:a {: RESULT = new Statement(a); :} | funDefn:func {: RESULT = func; :};

//arithExp:a {: RESULT = new Statement(a); :} | Car:car {:RESULT = new Statement(car); :} | Cdr:cdr {:RESULT = new Statement(cdr); :} | Pair:pair {:RESULT = new Statement(pair);:} | List:lst {:RESULT = new Statement(lst); :} | str:s {: RESULT = new Statement(s); :} | Substr:str {: RESULT = new Statement(str); :} | funDefn:func {: RESULT = func; :};

/*
definition ::= VAR:v ASSIGN comparisonExpression:c SEMI {:
		   RESULT = new StmtDefinition(v, e);
		:} | VAR:v ASSIGN conditionalExpression:e{:
		   RESULT = new StmtDefinition(v, e);
		:} ;

*/

/*
ifdefn ::= VAR:v ASSIGN comparisonExpression:c {:
		   RESULT = new StmtDefinition(v, e);
		:};

*/




args ::= args:aList COMMA expr:a {: // a < b < c < d =>a,b and b,c and c,d
	aList.add(a);
	RESULT = aList; :} |
	expr:a{:
	ArrayList<Exp> result = new ArrayList<>();
	result.add(a);
	RESULT = result;
	 :};

argsE ::= args:aList {: RESULT = aList; :} | emptyA:e {: RESULT = e; :};


funcall::= LPAREN funDefn:procedure RPAREN LPAREN argsE:arguments RPAREN{: RESULT = new ExpFunCall(procedure, arguments); :} | VAR:procedure LPAREN argsE:arguments RPAREN {: RESULT = new ExpFunCall(procedure, arguments); :}; //

//funcall ::= VAR:name LPAREN argsE:arguments RPAREN {: RESULT = new ExpFunCall(name, arguments); :};


//conditionalExpression:conditional {:RESULT = conditional;:} |

//
//conditionalExpression ::= IF expression:pred THEN stmt:consq ELSE stmt:alt {:RESULT = new ExpConditional(pred, new StmtSequence(consq), new StmtSequence(alt)); :} |IF expression:pred THEN stmt:consq {: RESULT = new ExpConditional(pred,new StmtSequence(consq)); :};

//conditionalExpression ::= IF expression:pred THEN stmt:consq else:alt {:RESULT = new ExpConditional(pred, new StmtSequence(consq), new StmtSequence(new Statement(alt))); :}; //|IF expression:pred THEN stmt:consq {: RESULT = new ExpConditional(pred,new StmtSequence(consq)); :};
//else::= ELSE stmt:alt {: RESULT = alt; :} ;



case ::= CASE LBRACE clauseLst:cList RBRACE {: RESULT = new ExpCase(cList); :};

clauseLst ::= clauseLst:cList COMMA clause:c {:
				cList.add(c);
				RESULT = cList; :} |
			clause:c {:
				ArrayList<Exp> cList = new ArrayList<Exp>();
				cList.add(c);
				RESULT = cList; :};

clause ::= expression:pred COLON compoundExpr:conseq {: RESULT = new ExpClause(pred, conseq); :};


ifStmt ::= IF expression:e THEN compoundExpr:conseq else:alt SEMI {:
				RESULT = new ExpIf(e, conseq, alt); :};

else  ::= ELSE compoundExpr:alt {: RESULT = alt; :} |
			empty {: RESULT = new ExpLit(); :};




let ::= LET LPAREN bindList:bindLst RPAREN LBRACE stmtList:b RBRACE  {:
	 		RESULT = new ExpLet(bindLst, b); :};

bindList ::= bindList:bindLst COMMA binding:b {:
                bindLst.add(b);
                RESULT = bindLst; :} |
            binding:b {:
                ArrayList<ExpBind> result = new ArrayList<ExpBind>();
                result.add(b);
                RESULT = result; :};

binding ::= VAR:v EQUAL expression:e {: RESULT = new ExpBind(v, e); :};




Not ::= NOT Not:n {: RESULT = new ExpNot(n); :}	| comparisonExpression:c {: RESULT = c;:};	 //| Or:r{: RESULT = r; :} | empty; //logical expressions

And ::= And:a AND Not:n{:  RESULT = new ExpAnd(a,n); :} | Not:n{: RESULT = n; :};// | empty;				//comparisonExpression:c {: RESULT = new Expexpression(a,e); :} | comparisonExpression:c {: RESULT = e;:};

expression ::= expression:r OR And:a {: RESULT = new ExpOr(r,a);:} | And:a{: RESULT = a; :}; 		//expression:a {: RESULT = new ExpOr(r,a);:} | expression:a {: RESULT = a;:};



/* -------- OMITTED -------------	
comparisonExpression ::= comparisonExpression:c LESS arithExp:b {: // x < y < y comparison expressions
			RESULT = new ExpLess(c, b); :} |
		comparisonExpression:c LESSEQ arithExp:b {: 
			RESULT = new ExpLessEq(c, b); :} |
		comparisonExpression:c GREATER arithExp:b {: 
			RESULT = new ExpGreater(c, b); :} |
		comparisonExpression:c GREATEREQ arithExp:b {: 
			RESULT = new ExpGreaterEq(c, b); :} |
		comparisonExpression:c EQUAL arithExp:b {: 
			RESULT = new ExpEqual(c,b); :} |
		comparisonExpression:c NEQUAL arithExp:b {: 
			RESULT = new ExpNotEqual(c,b); :} |
		arithExp:a {: RESULT = a; :};			// |comparatorList:clist {: RESULT = new ExpComparator(clist); :}; //


bitwiseBinOp ::= bitwiseBinOp:b BIT_AND comparisonExpression:a {:
					RESULT = new ExpBitwiseAnd(b, a); :} |
				bitwiseBinOp:b BIT_OR comparisonExpression:a {:
					RESULT = new ExpBitwiseOr(b, a); :} |
				comparisonExpression:c {: RESULT = c;:};

*/




comparisonExpression ::= comparisonExpression:c LESS bitwiseBinOp:b {: // x < y < y comparison expressions
			RESULT = new ExpLess(c, b); :} |
		comparisonExpression:c LESSEQ bitwiseBinOp:b {: 
			RESULT = new ExpLessEq(c, b); :} |
		comparisonExpression:c GREATER bitwiseBinOp:b {: 
			RESULT = new ExpGreater(c, b); :} |
		comparisonExpression:c GREATEREQ bitwiseBinOp:b {: 
			RESULT = new ExpGreaterEq(c, b); :} |
		comparisonExpression:c EQUAL bitwiseBinOp:b {: 
			RESULT = new ExpEqual(c,b); :} |
		comparisonExpression:c NEQUAL bitwiseBinOp:b {: 
			RESULT = new ExpNotEqual(c,b); :} |
		bitwiseBinOp:b {: RESULT = b; :};			// |comparatorList:clist {: RESULT = new ExpComparator(clist); :}; //


bitwiseBinOp ::= bitwiseBinOp:b BIT_AND arithExp:a {:
					RESULT = new ExpBitwiseAnd(b, a); :} |
				bitwiseBinOp:b BIT_OR arithExp:a {:
					RESULT = new ExpBitwiseOr(b, a); :} |
				arithExp:a {: RESULT = a; :};



/*
comparatorList ::= comparatorList: cList LESS comparisonExpression: e {:
		cList.add(new ExpLessThan(((ExpBinOp)cList.get(cList.size()-1)).getExpR(),e));
		RESULT = cList;:}|
		arithExp: e {:ArrayList<Exp> result = new ArrayList<>();result.add(e);RESULT = result; :};
*/


arithExp ::= arithExp:a PLUS term:t {: //arithmatic expressions
			RESULT = new ExpAdd(a, t); :} |
		arithExp:a MINUS term:t  {:
			RESULT = new ExpSub(a, t); :} |
		term:t {: RESULT = t; :};

term ::= term:t MUL factor:f {: // x := f(2+1) + 1 * y
		RESULT = new ExpMul(t, f); :} |
	 term:t DIV factor:f {:
		RESULT = new ExpDiv(t, f); :} |
	 term:t MOD factor:f {:
		RESULT = new ExpMod(t, f); :} |
	 term:t INTDIV factor:f {:
		RESULT = new ExpIntDiv(t, f); :} |
	 factor:f {: RESULT = f; :};

factor ::= bitwiseNot:n EXP factor:f {:RESULT = new ExpPow(n,f); :} | bitwiseNot:n {: RESULT = n; :};

bitwiseNot ::= BIT_NOT bitwiseNot:n {: RESULT = new ExpBitwiseNot(n); :} |  atom:a {: RESULT = a; :};

atom ::= INT:ilit {: RESULT = new ExpLit<Integer>(ilit); :}| DOUBLE:dlit {: RESULT = new ExpLit<Double>(dlit); :} | BOOL:blit {: RESULT = new ExpLit<Boolean>(blit); :}|STRING: slit {: RESULT = new ExpLit<String>(slit); :}|CHAR:clit {: RESULT = new ExpLit<Character>(clit); :}|
	  List:lst {:RESULT = new Statement(lst); :} | vector:v {: RESULT = new Statement(v); :} | NIL {: RESULT = new ExpList(); :}| LPAREN expression:a RPAREN {: RESULT = a; :} | funcall:fcall {:RESULT = fcall;:} | VAR:var {:RESULT = new ExpVar(var);:}; //
	   

emptyA ::= {: ArrayList<Exp> result = new ArrayList<>(); RESULT = result; :} ;
emptyS ::= {: ArrayList<String> result = new ArrayList<>(); RESULT = result; :} ;
empty ::= ;
emptyElse ::= ;
