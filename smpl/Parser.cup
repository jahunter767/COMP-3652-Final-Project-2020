import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// keywords
terminal DEF, PROC, CALL, LET, IF, THEN, ELSE, CASE;

// standard I/O
terminal PRINT, PRINTLN, READ, READINT;

// special symbols
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQPAREN, RSQPAREN, VECT_OPEN, VECT_CLOSE;
terminal ASSIGN, BIND, COMMA, DOT, COLON, SEMI;

// compound data operators
terminal LSTCONCAT;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, EXP;

// bit-wise operators
terminal BIT_AND, BIT_OR, BIT_NOT;

// comparators
terminal LESS, LESSEQ, EQUAL, GREATEREQ, GREATER, NEQUAL;

// boolean operators
terminal AND, OR, NOT;

// terminals with values
terminal String VAR;
terminal Integer INT;
terminal Double DOUBLE;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String STRING;
terminal NIL;


//other terminals
terminal LIST,FUN,SIZE,TRUE,FALSE;

/* Non terminals */
non terminal ArithProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;

non terminal Statement print;
non terminal Exp read;

non terminal StmtDefinition definition;


non terminal Exp body;
non terminal StmtSequence compoundExpr;

/*
non terminal StmtDefinition ifdefn;
*/

/* ** Fix these declarations ** */

non terminal StmtFunDefn funDefn;
non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;

non terminal ArrayList<Exp> args;
non terminal ArrayList<Exp> argsE;
non terminal ExpFunCall funcall;


/* **** */


/*
non terminal ArrayList<Exp> comparatorList;
non terminal StmtConditionalStmt conditionalIf;
non terminal StmtConditionalElseStmt conditionalIfElse;
*/

/*
non terminal Statement ifstmt;
non terminal Statement else;
non terminal Statement emptyElse;
*/


non terminal Exp Not;
non terminal Exp And;
non terminal Exp Or;



non terminal Exp arithExp;
non terminal Exp bitwiseBinOp;


non terminal Exp comparisonExpression;

/*
non terminal Exp conditionalExpression;
*/

non terminal Exp term;
non terminal Exp factor;
non terminal Exp atom;

non terminal Exp expr; // for all expressions
non terminal Exp Defnexpr; // for all definition expressions 
non terminal Exp str; // for strings
non terminal Substr Substr; // for substrings

non terminal Eqv Eqv; // for eqv
non terminal Equal Equal; // for equals

non terminal Exp Pair;// for pairs
non terminal Exp List;// for list

non terminal Car Car; // for car
non terminal Cdr Cdr; // for cdr


non terminal Exp empty;
non terminal ArrayList<Exp> emptyA;
non terminal ArrayList<String> emptyS;

/* Grammar rules */

program ::= stmtList:s {: RESULT = new ArithProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new StmtSequence(s);
		:};

stmt ::= List:lst {:RESULT = new Statement(lst); :}| read:r SEMI {: RESULT = new Statement(r); :} | print:p SEMI {: RESULT = p; :} | funDefn:func {: RESULT = func; :} | definition:d {: RESULT = d; :} | str:s {: RESULT = new Statement(s); :} | And:a {: RESULT = new Statement(a); :} SEMI; // |conditionalExpression:conditional {: RESULT = new Statement(conditional); :}; // 



print ::= PRINT LPAREN And:e RPAREN {: RESULT = new StmtPrint(e); :} |
		PRINTLN LPAREN And:e RPAREN {: RESULT = new StmtPrintln(e); :};

read ::= READ LPAREN RPAREN {: RESULT = new ExpRead(); :} |
		READINT LPAREN RPAREN {: RESULT = new ExpReadInt(); :};


body ::= compoundExpr:sList {: RESULT = sList; :} |
		And:e {: RESULT = e; :};

compoundExpr ::= LBRACE stmtList:sList RBRACE {: RESULT = sList; :};





//Car:car {:RESULT = new Statement(car); :} | Cdr:cdr {:RESULT = new Statement(cdr); :} |Pair:pair {:RESULT = new Statement(pair);:} | List:lst {:RESULT = new Statement(lst); :} | Eqv:eqv {:RESULT = new Statement(eqv); :} |Equal:equal {:RESULT = new Statement(equal); :} |Substr:subs {:RESULT = new Statement(subs); :} |

str ::= STRING:s {: RESULT = new ExpLit<String>(s); :};

// builtin functions - These are temp.. eventually will be removed

//Substr::= SUBSTR LPAREN expr:e COMMA arithExp:start COMMA arithExp:end RPAREN {: RESULT = new Substr(e,start,end); :};
//Eqv::= EQUIV_PRED LPAREN expr:exp1 COMMA expr:exp2  RPAREN {: RESULT = new Eqv(exp1,exp2); :};
//Equal ::= EQUAL_PRED LPAREN expr:exp1 COMMA expr:exp2  RPAREN {: RESULT = new Equal(exp1,exp2); :};

//Car::= CAR LPAREN expr:exp1 RPAREN {: RESULT = new Car(exp1); :};
//Cdr::= CDR LPAREN expr:exp1  RPAREN {: RESULT = new Cdr(exp1); :};

//Pair::= PAIR LPAREN expr:obj1 COMMA expr:obj2 RPAREN {: RESULT = new ExpPair(obj1,obj2);:};

List::= LIST LPAREN argsE:arguments RPAREN {:RESULT = new ExpList(arguments); :};




funDefn ::= PROC LPAREN paramListE:parameters RPAREN LBRACE stmtList:statements RBRACE {: RESULT = new StmtFunDefn(parameters, statements); :} ; // PROC LPAREN paramListE:p RPAREN DEFINE And:a SEMI {: RESULT = new StmtFunDefn(v,p,new StmtSequence(new Statement(a))); :} |  


paramList ::= paramList:pList COMMA VAR:var {: 
	pList.add(var);
	RESULT = pList; :} |
	VAR:var {:
	ArrayList<String> result = new ArrayList<String>();
	result.add(var);
	RESULT = result;
	:}; 


paramListE ::= paramList:paramList {: RESULT = paramList; :} | emptyS:e {: RESULT = e; :};




definition ::= DEF VAR:v Defnexpr:exp {: RESULT = new StmtDefinition(v,exp); :};

Defnexpr ::= List:lst {:RESULT = new Statement(lst); :} | str:s {: RESULT = new Statement(s); :} | And:a SEMI {: RESULT = new Statement(a); :} | funDefn:func {: RESULT = func; :};
//Car:car {:RESULT = new Statement(car); :} | Cdr:cdr {:RESULT = new Statement(cdr); :} | Pair:pair {:RESULT = new Statement(pair);:} | List:lst {:RESULT = new Statement(lst); :} | str:s {: RESULT = new Statement(s); :} | Substr:str {: RESULT = new Statement(str); :} |

expr ::= List:lst {:RESULT = new Statement(lst); :} | str:s {: RESULT = new Statement(s); :} | And:a {: RESULT = new Statement(a); :} | funDefn:func {: RESULT = func; :};
//arithExp:a {: RESULT = new Statement(a); :} | Car:car {:RESULT = new Statement(car); :} | Cdr:cdr {:RESULT = new Statement(cdr); :} | Pair:pair {:RESULT = new Statement(pair);:} | List:lst {:RESULT = new Statement(lst); :} | str:s {: RESULT = new Statement(s); :} | Substr:str {: RESULT = new Statement(str); :} | funDefn:func {: RESULT = func; :};

/*
definition ::= VAR:v ASSIGN comparisonExpression:c SEMI {:
		   RESULT = new StmtDefinition(v, e);
		:} | VAR:v ASSIGN conditionalExpression:e{:
		   RESULT = new StmtDefinition(v, e);
		:} ;

*/

/*
ifdefn ::= VAR:v ASSIGN comparisonExpression:c {:
		   RESULT = new StmtDefinition(v, e);
		:};

*/




args ::= args:aList COMMA expr:a {: // a < b < c < d =>a,b and b,c and c,d
	aList.add(a);
	RESULT = aList; :} |
	expr:a{:
	ArrayList<Exp> result = new ArrayList<>();
	result.add(a);
	RESULT = result;
	 :};

argsE ::= args:aList {: RESULT = aList; :} | emptyA:e {: RESULT = e; :};


funcall::= LPAREN funDefn:procedure RPAREN LPAREN argsE:arguments RPAREN{: RESULT = new ExpFunCall(procedure, arguments); :} | VAR:procedure LPAREN argsE:arguments RPAREN {: RESULT = new ExpFunCall(procedure, arguments); :}; //

//funcall ::= VAR:name LPAREN argsE:arguments RPAREN {: RESULT = new ExpFunCall(name, arguments); :};


//conditionalExpression:conditional {:RESULT = conditional;:} |

//
//conditionalExpression ::= IF And:pred THEN stmt:consq ELSE stmt:alt {:RESULT = new ExpConditional(pred, new StmtSequence(consq), new StmtSequence(alt)); :} |IF And:pred THEN stmt:consq {: RESULT = new ExpConditional(pred,new StmtSequence(consq)); :};

//conditionalExpression ::= IF And:pred THEN stmt:consq else:alt {:RESULT = new ExpConditional(pred, new StmtSequence(consq), new StmtSequence(new Statement(alt))); :}; //|IF And:pred THEN stmt:consq {: RESULT = new ExpConditional(pred,new StmtSequence(consq)); :};
//else::= ELSE stmt:alt {: RESULT = alt; :} ;



/*
conditionalExpression ::= IF And:pred THEN ifstmt:consq ELSE ifstmt:alt SEMI{:RESULT = new ExpConditional(pred, new StmtSequence(consq), new StmtSequence(alt)); :} |
			 IF And:pred THEN ifstmt:consq SEMI {: RESULT = new ExpConditional(pred,new StmtSequence(consq));:} |
			IF And:pred THEN LBRACE stmtList:consq RBRACE {:RESULT = new ExpConditional(pred,consq);:}|
			IF And:pred THEN LBRACE stmtList:consq RBRACE ELSE LBRACE stmtList:alt RBRACE{:RESULT = new ExpConditional(pred, consq, alt); :};


ifstmt ::= And:exp {: RESULT = new Statement(exp); :} |
	   ifdefn:exp {: RESULT = exp; :};


*/

//else::= ELSE stmt:alt {: RESULT = alt; :} ;




//conditionalIf ::= IF And:pred THEN And:consq {: RESULT = new StmtConditionalStmt(pred,new StmtSequence(new Statement(consq))); :} | IF And:pred THEN LBRACE stmtList:consq RBRACE {: RESULT = new StmtConditionalStmt(pred,consq); :}; // | IF And:pred THEN stmt:consq ELSE LBRACE stmt:alt RBRACE {: RESULT = new StmtConditionalElseStmt(pred,new StmtSequence(consq),new StmtSequence(alt)); :} ;

//conditionalIfElse ::= IF And:pred THEN LBRACE stmtList:consq RBRACE ELSE LBRACE stmtList:alt RBRACE {: RESULT = new StmtConditionalElseStmt(pred,new StmtSequence(consq),alt); :};// |;

//conditionalIfElse ::= IF And:pred THEN stmtList:consq ELSE stmtList:alt {: RESULT = new StmtConditionalElseStmt(pred, new StmtSequence(consq),new StmtSequence(alt)); :} ;//| IF And:pred THEN LBRACE stmtList:consq RBRACE ELSE LBRACE stmtList:alt RBRACE {: RESULT = new StmtConditionalElseStmt(pred,consq,alt); :};




Not ::= NOT Not:n {: RESULT = new ExpNot(n); :}	| comparisonExpression:c {: RESULT = c;:};	 //| Or:r{: RESULT = r; :} | empty; //logical expressions

And ::= And:a AND Or:r{:  RESULT = new ExpAnd(a,r); :} | Or:r{: RESULT = r; :};// | empty;				//comparisonExpression:c {: RESULT = new ExpAnd(a,e); :} | comparisonExpression:c {: RESULT = e;:};

Or ::= Or:r OR Not:n {: RESULT = new ExpOr(r,n);:} | Not:n{: RESULT = n; :}; 		//And:a {: RESULT = new ExpOr(r,a);:} | And:a {: RESULT = a;:};



	
comparisonExpression ::= comparisonExpression:c LESS bitwiseBinOp:b {: // x < y < y comparison expressions
			RESULT = new ExpLess(c, b); :} |
		comparisonExpression:c LESSEQ bitwiseBinOp:b {: 
			RESULT = new ExpLessEq(c, b); :} |
		comparisonExpression:c GREATER bitwiseBinOp:b {: 
			RESULT = new ExpGreater(c, b); :} |
		comparisonExpression:c GREATEREQ bitwiseBinOp:b {: 
			RESULT = new ExpGreaterEq(c, b); :} |
		comparisonExpression:c EQUAL bitwiseBinOp:b {: 
			RESULT = new ExpEqual(c,b); :} |
		comparisonExpression:c NEQUAL bitwiseBinOp:b {: 
			RESULT = new ExpNotEqual(c,b); :} |
		bitwiseBinOp:b {: RESULT = b; :};			// |comparatorList:clist {: RESULT = new ExpComparator(clist); :}; //


bitwiseBinOp ::= bitwiseBinOp:b BIT_AND arithExp:a {:
					RESULT = new ExpBitwiseAnd(b, a); :} |
				bitwiseBinOp:b BIT_OR arithExp:a {:
					RESULT = new ExpBitwiseOr(b, a); :} |
				arithExp:a {: RESULT = a; :};


/*
comparatorList ::= comparatorList: cList LESS comparisonExpression: e {:
		cList.add(new ExpLessThan(((ExpBinOp)cList.get(cList.size()-1)).getExpR(),e));
		RESULT = cList;:}|
		arithExp: e {:ArrayList<Exp> result = new ArrayList<>();result.add(e);RESULT = result; :};
*/


arithExp ::= arithExp:a PLUS term:t {: //arithmatic expressions
			RESULT = new ExpAdd(a, t); :} |
		arithExp:a MINUS term:t  {:
			RESULT = new ExpSub(a, t); :} |
		term:t {: RESULT = t; :};

term ::= term:t MUL factor:f {: // x := f(2+1) + 1 * y
		RESULT = new ExpMul(t, f); :} |
	 term:t DIV factor:f {:
		RESULT = new ExpDiv(t, f); :} |
	 term:t MOD factor:f {:
		RESULT = new ExpMod(t, f); :} |
	 factor:f {: RESULT = f; :};

factor ::= atom:a EXP factor:f {:RESULT = new ExpPow(a,f); :} | atom:a {: RESULT = a; :};

atom ::= INT:ilit {: RESULT = new ExpLit(ilit); :} |
	   LPAREN And:a RPAREN {: RESULT = a; :} | funcall:fcall {:RESULT = fcall;:} | VAR:var {:RESULT = new ExpVar(var);:}; //
	   

emptyA ::= {: ArrayList<Exp> result = new ArrayList<>(); RESULT = result; :} ;
emptyS ::= {: ArrayList<String> result = new ArrayList<>(); RESULT = result; :} ;
empty ::= ;
emptyElse ::= ;
