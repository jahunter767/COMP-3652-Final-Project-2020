import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */
/* REMEMBER THESE ARE REASSIGNABLE BY THE USER */
// built-ins
terminal PAIR, CAR,LIST;
terminal SIZE, CDR, PAIR_PRED;
terminal EQUIV_PRED, EQUAL_PRED;
terminal SUBSTR;

// keywords
terminal DEF, PROC, CALL, LET, IF, THEN, ELSE, CASE, FUN;

// standard I/O
terminal PRINT, PRINTLN, READ, READINT;

// special symbols
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQPAREN, RSQPAREN, VECT_OPEN, VECT_CLOSE;
terminal ASSIGN, BIND, COMMA, SEMI;

// compound data operators
terminal LSTCONCAT;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, EXP;

// bit-wise operators
terminal BIT_AND, BIT_OR, BIT_NOT;

// comparators
terminal LESS, LESSEQ, EQUAL, GREATEREQ, GREATER, NEQUAL;

// boolean operators
terminal AND, OR, NOT;

// terminals with values
terminal Integer INT;
terminal Double DOUBLE;
terminal String TRUE;
terminal String FALSE;
terminal char CHAR;
terminal String STRING;
terminal String VAR;


/* Non terminals */
non terminal ArithProgram program;
non terminal StmtSequence stmtList;
non terminal StmtSequence elseStmt;
non terminal Statement stmt;
non terminal Statement stmt1;
non terminal StmtDefinition definition;

/* ** Fix these declarations ** */
non terminal StmtFunDefn funDefn;
non terminal StmtSequence funDefe;
non terminal ArrayList<Object> paramList;
non terminal ArrayList<Object> paramListE;
non terminal ExpFunCall funCall;
non terminal StmtIfDefn ifStmt;
non terminal SMPLPair pair;
/* **** */

non terminal SMPLExp expression;
non terminal SMPLExp term;
non terminal SMPLExp factor;
non terminal empty;
non terminal SMPLExp expression1; //Relational
non terminal SMPLExp expression2; //NOT
non terminal SMPLExp expression3; //AND
non terminal SMPLExp expression4; //OR
non terminal SMPLExp car;
non terminal SMPLExp cdr;
non terminal SMPLExp isPair;
/* Grammar rules */

program ::= stmtList:s {: RESULT = new ArithProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new StmtSequence(s);
		:};

stmt ::= definition:d {: RESULT = d; :} |
	 expression4:e {: RESULT = new Statement(e); :} SEMI |
	 funDefn:f {:RESULT = f;:}  | ifStmt:i {:RESULT=i;:} ;

ifStmt::= IF expression4:pred THEN stmtList:cons ELSE stmt:alt {: RESULT = new StmtIfDefn(pred,cons, alt);:};
pair::= PAIR LPAREN expression4:p1 COMMA expression4:p2 RPAREN {: RESULT = new SMPLPair(p1,p2);:} | LPAREN expression4:p1 COMMA expression4:p2 RPAREN {: RESULT = new SMPLPair(p1,p2);:};
car::= CAR pair:p {:RESULT = p.car();:};
cdr::= CDR pair:p {:RESULT = p.cdr();:};
isPair::= PAIR_PRED pair:p {:RESULT=LinkedList.isPair(p);:} | error:e  {: RESULT = new SMPLBoolean(new Boolean(false));:};
funDefn ::= FUN VAR:v LPAREN paramListE:pe RPAREN BIND funDefe:fe {: RESULT = new StmtFunDefn(v,pe,fe);:};
funDefe ::= LBRACE stmtList:sl RBRACE {: RESULT = sl;:} | expression4:e SEMI{: RESULT = new StmtSequence (new Statement(e));:} ;

paramList ::= expression4:e COMMA paramList:p {: p.add(e); RESULT = p;:}| expression4:e {:ArrayList<Object> result = new ArrayList<>();result.add(e);RESULT = result;:} ; /* complete this */

paramListE ::= paramList:p {:RESULT = p;:} | empty ;

definition ::= VAR:v ASSIGN expression4:e SEMI {:
		   RESULT = new StmtDefinition(v, e);:} | 
		   VAR:v ASSIGN ifStmt:i {: RESULT = new StmtDefinition(v, i);:} ;
expression4::= expression3:e3 OR expression4:e4 {:RESULT = new StmtOr(e3,e4);:}   | expression3: e3 {:RESULT = e3; :};
expression3::= expression2:e2 AND expression3:e3 {:RESULT = new StmtAnd(e2,e3);:} | expression2: e2 {:RESULT = e2; :};
expression2::= NOT expression1:e1  {: RESULT = new StmtNot(e1); :} | expression1:e1 {: RESULT = e1; :} ; 
expression1::= expression:e GREATER expression1:e1  {: RESULT = new CompareG(e,e1);:}   | 
			   expression:e GREATEREQ expression1:e1 {: RESULT = new CompareGE(e,e1);:}  |
			   expression:e LESS expression1:e1 {: RESULT = new CompareL(e,e1);:}   |
			   expression:e LESSEQ expression1:e1 {: RESULT = new CompareLE(e,e1);:} |
			   expression:e {: RESULT = e; :} ;
expression ::= 	expression:e PLUS term:t {:
			RESULT = e.add(t); :} |
		expression:e MINUS term:t {:
			RESULT = e.sub(t); :} |
		term:t {: RESULT = t; :} ; 

term ::= term:t MUL factor:f {:
		RESULT = t.mul(f); :} |
	 term:t DIV factor:f {:
		RESULT = t.div(f); :} |
	 term:t MOD factor:f {:
		RESULT = t.mod(f); :} |
	 factor:f {: RESULT = f; :};

factor ::= INT:ilit {: RESULT = new SMPLInteger(ilit); :} |
		DOUBLE:ilit {: RESULT = new SMPLFloat(ilit); :} |
		TRUE:ilit {: RESULT = new SMPLBoolean(new Boolean(true)); :} |
		FALSE:ilit {: RESULT = new SMPLBoolean(new Boolean(false)); :} |
		STRING:ilit {: RESULT = new SMPLString(ilit); :} |
		CHAR:ilit {: RESULT = new SMPLCharacter(ilit); :} |
	   VAR:var {: RESULT = new ExpVar(var); :} |
	   LPAREN expression:e RPAREN {: RESULT = e; :}	|
	   funCall:f {:RESULT = f;:} |
	   pair:p {: RESULT = p;:}   | car:c {:RESULT = c;:} | cdr:c {:RESULT = c;:} | isPair:p {:RESULT=p;:}; 
funCall ::= VAR:v LPAREN paramListE:pe RPAREN {:RESULT = new ExpFunCall(v,pe);:};

empty ::= ;

