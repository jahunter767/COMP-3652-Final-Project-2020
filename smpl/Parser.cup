import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// keywords
terminal DEF, PROC, CALL, LET, IF, THEN, ELSE, CASE;

// standard I/O
terminal PRINT, PRINTLN, READ, READINT;

// special symbols
terminal LBRACE, RBRACE, LPAREN, RPAREN, LSQPAREN, RSQPAREN, VECT_OPEN, VECT_CLOSE;
terminal ASSIGN, BIND, COMMA, DOT, COLON, SEMI,POP;

// compound data operators
terminal LSTCONCAT;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, EXP, INTDIV;

// bit-wise operators
terminal BIT_AND, BIT_OR, BIT_NOT;

// comparators
terminal LESS, LESSEQ, EQUAL, GREATEREQ, GREATER, NEQUAL;

// boolean operators
terminal AND, OR, NOT;

// terminals with values
terminal String VAR;
terminal Integer INT;
terminal Double DOUBLE;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String STRING;
terminal NIL;


//other terminals
terminal LIST,FUN,SIZE,TRUE,FALSE;

/* Non terminals */
non terminal ArithProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;

non terminal Statement print;
non terminal Exp read;

non terminal StmtDefinition definition;
non terminal StmtAssignment assignment;

non terminal StmtFunDefn proc;
non terminal Exp body;
non terminal StmtSequence compoundExpr;

non terminal ExpLet let;
non terminal ArrayList<ExpBind> bindList;
non terminal ExpBind binding;




/*
non terminal StmtDefinition ifdefn;
*/

/* ** Fix these declarations ** */

non terminal StmtFunDefn funDefn;
non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;

non terminal ArrayList<Exp> args;
non terminal ArrayList<Exp> argsE;
non terminal ExpFunCall funcall;


/* **** */


/*
non terminal ArrayList<Exp> comparatorList;
non terminal StmtConditionalStmt conditionalIf;
non terminal StmtConditionalElseStmt conditionalIfElse;
*/

/*
non terminal Statement ifstmt;
non terminal Statement else;
non terminal Statement emptyElse;
*/

non terminal ExpCase case;
non terminal ArrayList<Exp> clauseLst;
non terminal ExpClause clause;

non terminal ExpIf ifStmt;
non terminal Exp else;

non terminal Exp Not;
non terminal Exp And;
non terminal Exp expression;



non terminal Exp arithExp;
non terminal Exp bitwiseBinOp;
non terminal Exp bitwiseNot;

non terminal Exp comparisonExpression;

/*
non terminal Exp conditionalExpression;
*/

non terminal Exp term;
non terminal Exp factor;
non terminal Exp atom;

non terminal Exp expr; // for all expressions
non terminal Exp Defnexpr; // for all definition expressions 
non terminal Exp ifexpr;
non terminal Exp str; // for strings
non terminal Exp concat; // for strings concat
non terminal Substr Substr; // for substrings

non terminal Eqv Eqv; // for eqv
non terminal Equal Equal; // for equals

non terminal Exp Pair;// for pairs
non terminal Exp List;// for list
non terminal Exp Listconcat;// for list concat

non terminal Car Car; // for car
non terminal Cdr Cdr; // for cdr


non terminal Exp vector;// for vector
non terminal ArrayList<Exp> vectorElementLst;
non terminal Exp vectorOps;
non terminal Exp vectorOpAssign;


non terminal Exp empty;
non terminal ArrayList<Exp> emptyA;
non terminal ArrayList<String> emptyS;

/* Grammar rules */

program ::= stmtList:s {: RESULT = new ArithProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new StmtSequence(s);
		:}; // | expression:e {:RESULT = new StmtSequence(new Statement(e)); :};

stmt ::= Listconcat:lst {:RESULT = new Statement(lst); :} |vectorOpAssign:v {: RESULT = new Statement(v); :}   | assignment:a {:RESULT = a; :}|let:l {: RESULT = new Statement(l); :} | case:c {: RESULT = new Statement(c); :} |ifStmt:i {: RESULT = new Statement(i); :}| read:r SEMI {: RESULT = new Statement(r); :} | print:p SEMI {: RESULT = p; :} | funDefn:func {: RESULT = func; :} | definition:d {: RESULT = d; :} | expression:a {: RESULT = new Statement(a); :} SEMI; // |conditionalExpression:conditional {: RESULT = new Statement(conditional); :}; // 

Defnexpr ::= Listconcat:lst {:RESULT = new Statement(lst); :}  |vectorOpAssign:v {: RESULT = new Statement(v); :} | case:c {: RESULT = new Statement(c); :} |ifStmt:i {: RESULT = new Statement(i); :} | expression:a SEMI {: RESULT = new Statement(a); :} | funDefn:func {: RESULT = func; :};

expr ::=  Listconcat:lst {:RESULT = new Statement(lst); :} | vectorOpAssign:v {: RESULT = new Statement(v); :}  | case:c {: RESULT = new Statement(c); :} |ifStmt:i {: RESULT = new Statement(i); :} | expression:a {: RESULT = new Statement(a); :} | funDefn:func {: RESULT = func; :};

ifexpr ::= ifStmt:i {: RESULT = new Statement(i); :} | expression:a {: RESULT = new Statement(a); :};


print ::= PRINT LPAREN expr:e RPAREN {: RESULT = new StmtPrint(e); :} |
		PRINTLN LPAREN expr:e RPAREN {: RESULT = new StmtPrintln(e); :};

read ::= READ LPAREN RPAREN {: RESULT = new ExpRead(); :} |
		READINT LPAREN RPAREN {: RESULT = new ExpReadInt(); :};


body ::= compoundExpr:sList {: RESULT = sList; :} |
		expression:e SEMI {: RESULT = e; :};

compoundExpr ::= LBRACE stmtList:sList RBRACE {: RESULT = sList; :} | expression:e{: RESULT = new StmtSequence(new Statement(e)); :};



List::= LIST LPAREN argsE:arguments RPAREN {:RESULT = new ExpList(arguments); :} | LSQPAREN argsE:arguments RSQPAREN {:RESULT = new ExpList(arguments); :};

Listconcat::= expression: exp1 LSTCONCAT expression: exp2 SEMI{: RESULT = new ExpListConcat(exp1, exp2); :};



vector ::= VECT_OPEN vectorElementLst:lst VECT_CLOSE {:
			RESULT = new ExpVector(lst); :};

vectorElementLst ::= vectorElementLst:lst COMMA expr:e {:
			lst.add(e);
			RESULT = lst; :} |
		expr:e {:
			ArrayList<Exp> lst = new ArrayList<Exp>();
			lst.add(e);
			RESULT = lst; :};

vectorOps ::= VAR:v LSQPAREN expr:i RSQPAREN {:
				RESULT = new ExpGetVectEl(v, i); :}|
			VAR:v DOT POP LPAREN expr:i RPAREN{:
				RESULT = new ExpPopVectEl(v, i); :};



vectorOpAssign ::= VAR:v LSQPAREN expr:i RSQPAREN ASSIGN expr:e SEMI{:RESULT = new ExpSetVectEl(v, i, e); :};






funDefn ::= PROC LPAREN paramListE:parameters RPAREN LBRACE stmtList:statements RBRACE {: RESULT = new StmtFunDefn(parameters, statements); :} |
		PROC LPAREN paramListE:parameters RPAREN stmt:s {: RESULT = new StmtFunDefn(parameters, new StmtSequence(s)); :} ;


proc ::= PROC LPAREN paramListE:parameters RPAREN stmt:s {:RESULT = new StmtFunDefn(parameters, new StmtSequence(s)); :};

paramList ::= paramList:pList COMMA VAR:var {: 
	pList.add(var);
	RESULT = pList; :} |
	VAR:var {:
	ArrayList<String> result = new ArrayList<String>();
	result.add(var);
	RESULT = result;
	:}; 


paramListE ::= paramList:paramList {: RESULT = paramList; :} | emptyS:e {: RESULT = e; :};




definition ::= DEF VAR:v Defnexpr:exp {: RESULT = new StmtDefinition(v,exp); :};

assignment ::= VAR:v ASSIGN expression:e SEMI {: RESULT = new StmtAssignment(v, e); :};



args ::= args:aList COMMA expr:a {: // a < b < c < d =>a,b and b,c and c,d
	aList.add(a);
	RESULT = aList; :} |
	expr:a{:
	ArrayList<Exp> result = new ArrayList<>();
	result.add(a);
	RESULT = result;
	 :};

argsE ::= args:aList {: RESULT = aList; :} | emptyA:e {: RESULT = e; :};


funcall::= LPAREN funDefn:procedure RPAREN LPAREN argsE:arguments RPAREN{: RESULT = new ExpFunCall(procedure, arguments); :} |
	 VAR:procedure LPAREN argsE:arguments RPAREN {: RESULT = new ExpFunCall(procedure, arguments); :}; //

//funcall ::= VAR:name LPAREN argsE:arguments RPAREN {: RESULT = new ExpFunCall(name, arguments); :};





case ::= CASE LBRACE clauseLst:cList RBRACE {: RESULT = new ExpCase(cList); :};

clauseLst ::= clauseLst:cList COMMA clause:c {:
				cList.add(c);
				RESULT = cList; :} |
			clause:c {:
				ArrayList<Exp> cList = new ArrayList<Exp>();
				cList.add(c);
				RESULT = cList; :};

clause ::= expression:pred COLON compoundExpr:conseq {: RESULT = new ExpClause(pred, conseq); :};


/*
// og code


ifStmt ::= IF expression:e THEN compoundExpr:conseq else:alt SEMI {:
				RESULT = new ExpIf(e, conseq, alt); :};

else  ::= ELSE compoundExpr:alt {: RESULT = alt; :} |
			empty {: RESULT = new ExpLit(); :};

// testing
ifStmt ::= IF expr:e THEN expr:e2 ELSE expr: e3 SEMI {: RESULT = new ExpIf(e, e2, e3); :} |
		IF expr:e THEN expr:e2 SEMI {: RESULT = new ExpIf(e, e2, null); :};


*/



//modified code

ifStmt ::= IF expression:e THEN expr:conseq else:alt SEMI{:
				RESULT = new ExpIf(e, conseq, alt); :}|
		IF expression:e THEN LBRACE stmtList:conseq RBRACE else:alt SEMI{:
				RESULT = new ExpIf(e, conseq, alt); :};

else  ::= ELSE expr:alt{: RESULT = alt; :}|
		ELSE LBRACE stmtList:alt RBRACE{: RESULT = alt; :} |
			empty {: RESULT = new ExpLit(); :};



let ::= LET LPAREN bindList:bindLst RPAREN LBRACE stmtList:b RBRACE  {:
	 		RESULT = new ExpLet(bindLst, b); :};

bindList ::= bindList:bindLst COMMA binding:b {:
                bindLst.add(b);
                RESULT = bindLst; :} |
            binding:b {:
                ArrayList<ExpBind> result = new ArrayList<ExpBind>();
                result.add(b);
                RESULT = result; :};

binding ::= VAR:v EQUAL expression:e {: RESULT = new ExpBind(v, e); :};




Not ::= NOT Not:n {: RESULT = new ExpNot(n); :}	| comparisonExpression:c {: RESULT = c;:};	 

And ::= And:a AND Not:n{:  RESULT = new ExpAnd(a,n); :} | Not:n{: RESULT = n; :};// | empty;		

expression ::= expression:r OR And:a {: RESULT = new ExpOr(r,a);:} | And:a{: RESULT = a; :}; 	




comparisonExpression ::= comparisonExpression:c LESS bitwiseBinOp:b {: // x < y < y comparison expressions
			RESULT = new ExpLess(c, b); :} |
		comparisonExpression:c LESSEQ bitwiseBinOp:b {: 
			RESULT = new ExpLessEq(c, b); :} |
		comparisonExpression:c GREATER bitwiseBinOp:b {: 
			RESULT = new ExpGreater(c, b); :} |
		comparisonExpression:c GREATEREQ bitwiseBinOp:b {: 
			RESULT = new ExpGreaterEq(c, b); :} |
		comparisonExpression:c EQUAL bitwiseBinOp:b {: 
			RESULT = new ExpEqual(c,b); :} |
		comparisonExpression:c NEQUAL bitwiseBinOp:b {: 
			RESULT = new ExpNotEqual(c,b); :} |
		bitwiseBinOp:b {: RESULT = b; :};			

bitwiseBinOp ::= bitwiseBinOp:b BIT_AND arithExp:a {:
					RESULT = new ExpBitwiseAnd(b, a); :} |
				bitwiseBinOp:b BIT_OR arithExp:a {:
					RESULT = new ExpBitwiseOr(b, a); :} |
				arithExp:a {: RESULT = a; :};




arithExp ::= arithExp:a PLUS term:t {: //arithmatic expressions
			RESULT = new ExpAdd(a, t); :} |
		arithExp:a MINUS term:t  {:
			RESULT = new ExpSub(a, t); :} |
		term:t {: RESULT = t; :};

term ::= term:t MUL factor:f {: // x := f(2+1) + 1 * y
		RESULT = new ExpMul(t, f); :} |
	 term:t DIV factor:f {:
		RESULT = new ExpDiv(t, f); :} |
	 term:t MOD factor:f {:
		RESULT = new ExpMod(t, f); :} |
	 term:t INTDIV factor:f {:
		RESULT = new ExpIntDiv(t, f); :} |
	 factor:f {: RESULT = f; :};

factor ::= bitwiseNot:n EXP factor:f {:RESULT = new ExpPow(n,f); :} | bitwiseNot:n {: RESULT = n; :};

bitwiseNot ::= BIT_NOT bitwiseNot:n {: RESULT = new ExpBitwiseNot(n); :} |  atom:a {: RESULT = a; :};

atom ::= INT:ilit {: RESULT = new ExpLit<Integer>(ilit); :}|
			 DOUBLE:dlit {: RESULT = new ExpLit<Double>(dlit); :} |
			 BOOL:blit {: RESULT = new ExpLit<Boolean>(blit); :}|
			STRING: slit {: RESULT = new ExpLit<String>(slit); :}|
			CHAR:clit {: RESULT = new ExpLit<Character>(clit); :}|
	  		List:lst {:RESULT = new Statement(lst); :} |
			 vector:v {: RESULT = new Statement(v); :} |
			vectorOps:vops {:RESULT = new Statement(vops);:}|
			 NIL {: RESULT = new ExpList(); :}|
			 LPAREN expression:a RPAREN {: RESULT = a; :} |
			 funcall:fcall {:RESULT = fcall;:} |
			 VAR:var{:RESULT = new ExpVar(var);:}; //
	   

emptyA ::= {: ArrayList<Exp> result = new ArrayList<>(); RESULT = result; :} ;
emptyS ::= {: ArrayList<String> result = new ArrayList<>(); RESULT = result; :} ;
empty ::= ;
emptyElse ::= ;
